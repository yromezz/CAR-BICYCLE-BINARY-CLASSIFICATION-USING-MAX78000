// /*******************************************************************************
// * Copyright (C) 2019-2023 Maxim Integrated Products, Inc., All rights Reserved.
// *
// * This software is protected by copyright laws of the United States and
// * of foreign countries. This material may also be protected by patent laws
// * and technology transfer regulations of the United States and of foreign
// * countries. This software is furnished under a license agreement and/or a
// * nondisclosure agreement and may only be used or reproduced in accordance
// * with the terms of those agreements. Dissemination of this information to
// * any party or parties not specified in the license agreement and/or
// * nondisclosure agreement is expressly prohibited.
// *
// * The above copyright notice and this permission notice shall be included
// * in all copies or substantial portions of the Software.
// *
// * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// * IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
// * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// * OTHER DEALINGS IN THE SOFTWARE.
// *
// * Except as contained in this notice, the name of Maxim Integrated
// * Products, Inc. shall not be used except as stated in the Maxim Integrated
// * Products, Inc. Branding Policy.
// *
// * The mere transfer of this software does not imply any licenses
// * of trade secrets, proprietary technology, copyrights, patents,
// * trademarks, maskwork rights, or any other form of intellectual
// * property whatsoever. Maxim Integrated Products, Inc. retains all
// * ownership rights.
// *******************************************************************************/

// // CarBicycle
// // This file was @generated by ai8xize.py --test-dir C:/MaximSDK/Examples/MAX78000/CNN --prefix CarBicycle --checkpoint-file ../ai8x-training/logs/2025.11.11-010241/CarBicycle-qat8-q.pth.tar --config-file networks/CarBicycle-hwc.yaml --sample-input ../ai8x-training/logs/2025.12.22-204923/sample_carbicycle.npy --fifo --softmax --device MAX78000 --timer 0 --display-checkpoint --verbose

// #include <stdlib.h>
// #include <stdint.h>
// #include <string.h>
// #include <stdio.h>
// #include "mxc.h"
// #include "cnn.h"
// #include "sampledata.h"
// #include "sampleoutput.h"

// volatile uint32_t cnn_time; // Stopwatch

// void fail(void)
// {
//   printf("\n*** FAIL ***\n\n");
//   while (1);
// }

// // Data input: HWC 3x128x128 (49152 bytes total / 16384 bytes per channel):
// static const uint32_t input_0[] = SAMPLE_INPUT_0;
// void load_input(void)
// {
//   // This function loads the sample data input -- replace with actual data

//   int i;
//   const uint32_t *in0 = input_0;

//   for (i = 0; i < 16384; i++) {
//     // Remove the following line if there is no risk that the source would overrun the FIFO:
//     while (((*((volatile uint32_t *) 0x50000004) & 1)) != 0); // Wait for FIFO 0
//     *((volatile uint32_t *) 0x50000008) = *in0++; // Write FIFO 0
//   }
// }

// // Expected output of layer 6 for CarBicycle given the sample input (known-answer test)
// // Delete this function for production code
// static const uint32_t sample_output[] = SAMPLE_OUTPUT;
// int check_output(void)
// {
//   int i;
//   uint32_t mask, len;
//   volatile uint32_t *addr;
//   const uint32_t *ptr = sample_output;

//   while ((addr = (volatile uint32_t *) *ptr++) != 0) {
//     mask = *ptr++;
//     len = *ptr++;
//     for (i = 0; i < len; i++)
//       if ((*addr++ & mask) != *ptr++) {
//         printf("Data mismatch (%d/%d) at address 0x%08x: Expected 0x%08x, read 0x%08x.\n",
//                i + 1, len, addr - 1, *(ptr - 1), *(addr - 1) & mask);
//         return CNN_FAIL;
//       }
//   }

//   return CNN_OK;
// }

// // Classification layer:
// static int32_t ml_data[CNN_NUM_OUTPUTS];
// static q15_t ml_softmax[CNN_NUM_OUTPUTS];

// void softmax_layer(void)
// {
//   cnn_unload((uint32_t *) ml_data);
//   softmax_q17p14_q15((const q31_t *) ml_data, CNN_NUM_OUTPUTS, ml_softmax);
// }

// int main(void)
// {
//   int i;
//   int digs, tens;

//   MXC_ICC_Enable(MXC_ICC0); // Enable cache

//   // Switch to 100 MHz clock
//   MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
//   SystemCoreClockUpdate();

//   printf("Waiting...\n");

//   // DO NOT DELETE THIS LINE:
//   MXC_Delay(SEC(2)); // Let debugger interrupt if needed

//   // Enable peripheral, enable CNN interrupt, turn on CNN clock
//   // CNN clock: APB (50 MHz) div 1
//   cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);

//   printf("\n*** CNN Inference Test CarBicycle ***\n");

//   cnn_init(); // Bring state machine into consistent state
//   cnn_load_weights(); // Load kernels
//   cnn_load_bias();
//   cnn_configure(); // Configure state machine
//   cnn_start(); // Start CNN processing
//   load_input(); // Load data input via FIFO

//   while (cnn_time == 0)
//     MXC_LP_EnterSleepMode(); // Wait for CNN

//   if (check_output() != CNN_OK) fail();
//   softmax_layer();

//   printf("\n*** PASS ***\n\n");

// #ifdef CNN_INFERENCE_TIMER
//   printf("Approximate data loading and inference time: %u us\n\n", cnn_time);
// #endif

//   cnn_disable(); // Shut down CNN clock, disable peripheral

//   printf("Classification results:\n");
//   for (i = 0; i < CNN_NUM_OUTPUTS; i++) {
//     digs = (1000 * ml_softmax[i] + 0x4000) >> 15;
//     tens = digs % 10;
//     digs = digs / 10;
//     printf("[%7d] -> Class %d: %d.%d%%\n", ml_data[i], i, digs, tens);
//   }

//   return 0;
// }

// /*
//   SUMMARY OF OPS
//   Hardware: 51,368,960 ops (50,432,000 macc; 936,960 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 0: 7,340,032 ops (7,077,888 macc; 262,144 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 1: 19,267,584 ops (18,874,368 macc; 393,216 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 2: 19,070,976 ops (18,874,368 macc; 196,608 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 3: 4,792,320 ops (4,718,592 macc; 73,728 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 4: 600,064 ops (589,824 macc; 10,240 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 5: 295,936 ops (294,912 macc; 1,024 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 6: 2,048 ops (2,048 macc; 0 comp; 0 add; 0 mul; 0 bitwise)

//   RESOURCE USAGE
//   Weight memory: 57,776 bytes out of 442,368 bytes total (13.1%)
//   Bias memory:   2 bytes out of 2,048 bytes total (0.1%)
// */











////version iii - without ascii art
// #include <stdio.h>
// #include <stdint.h>
// #include <string.h>

// #include "mxc_device.h"
// #include "mxc_sys.h"
// #include "icc.h"
// #include "pb.h"
// #include "led.h"
// #include "dma.h"
// #include "cnn.h"
// #include "camera.h"
// #include "mxc_delay.h"
// #include "tft_ili9341.h"

// // ---------------- CONFIG ----------------
// #define IMAGE_X 128
// #define IMAGE_Y 128
// #define CAMERA_FREQ (5 * 1000 * 1000)

// // Classes
// const char *classes[] = { "Car", "Bicycle" };

// // CNN output
// static int32_t ml_data[CNN_NUM_OUTPUTS];
// static q15_t ml_softmax[CNN_NUM_OUTPUTS];
// volatile uint32_t cnn_time;

// // Camera buffer
// static uint32_t cnn_input[IMAGE_X * IMAGE_Y];

// // ---------------------------------------

// void capture_image(void)
// {
//     uint8_t *raw, *data;
//     uint32_t len, w, h;
//     int cnt = 0;

//     camera_start_capture_image();
//     camera_get_image(&raw, &len, &w, &h);

//     for (int y = 0; y < h; y++) {
//         while ((data = get_camera_stream_buffer()) == NULL);
//         for (int x = 0; x < w * 4; x += 4) {
//             uint8_t r = data[x];
//             uint8_t g = data[x + 1];
//             uint8_t b = data[x + 2];
//             cnn_input[cnt++] = ((b << 16) | (g << 8) | r) ^ 0x00808080;
//         }
//         release_camera_stream_buffer();
//     }
// }

// int main(void)
// {
//     int i, digs, tens;

//     MXC_ICC_Enable(MXC_ICC0);
//     MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
//     SystemCoreClockUpdate();

//     printf("\n=== Car vs Bicycle Camera Demo ===\n");

//     MXC_DMA_Init();
//     int dma = MXC_DMA_AcquireChannel();

//     Camera_Power(POWER_ON);
//     camera_init(CAMERA_FREQ);
//     camera_setup(IMAGE_X, IMAGE_Y, PIXFORMAT_RGB888,
//                  FIFO_THREE_BYTE, STREAMING_DMA, dma);

//     cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK,
//                MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);

//     cnn_init();
//     cnn_load_weights();
//     cnn_load_bias();
//     cnn_configure();

//     printf("Press PB1 to capture image\n");

//     while (1) {
//         while (!PB_Get(0));   // wait press
//         MXC_Delay(200000);    // debounce

//         capture_image();

//         cnn_start();
//         for (i = 0; i < IMAGE_X * IMAGE_Y; i++) {
//             while (*((volatile uint32_t*)0x50000004) & 1);
//             *((volatile uint32_t*)0x50000008) = cnn_input[i];
//         }

//         while (cnn_time == 0) __WFI();

//         cnn_unload((uint32_t*)ml_data);
//         softmax_q17p14_q15((q31_t*)ml_data, CNN_NUM_OUTPUTS, ml_softmax);

//         printf("\nInference time: %dus\n", cnn_time);
//         printf("Results:\n");

//         for (i = 0; i < CNN_NUM_OUTPUTS; i++) {
//             digs = (1000 * ml_softmax[i] + 0x4000) >> 15;
//             tens = digs % 10;
//             digs /= 10;
//             printf("[%7d] %s: %d.%d%%\n",
//                    ml_data[i], classes[i], digs, tens);
//         }

//         cnn_time = 0;
//         printf("\nPress PB1 to capture again\n");
//     }
// }



















////version ii - with ascii

/****************************************************************************** 
* CarBicycle classification with camera capture, PB1 button, CNN
* ASCII preview adapted from Cats-Dogs demo
******************************************************************************/

#include <stdio.h>
#include <stdint.h>
#include <string.h>

#include "mxc_device.h"
#include "mxc_sys.h"
#include "icc.h"
#include "pb.h"
#include "led.h"
#include "dma.h"
#include "cnn.h"
#include "camera.h"
#include "mxc_delay.h"

// ---------------- CONFIG ----------------
#define IMAGE_X 128
#define IMAGE_Y 128
#define CAMERA_FREQ (5 * 1000 * 1000)

// Classes
const char *classes[] = { "Car", "Bicycle" };

// CNN output
static int32_t ml_data[CNN_NUM_OUTPUTS];
static q15_t ml_softmax[CNN_NUM_OUTPUTS];
volatile uint32_t cnn_time;

// Camera buffer (CNN input)
static uint32_t cnn_input[IMAGE_X * IMAGE_Y];

// ---------------------------------------
// ASCII ART SUPPORT (compact)
#define ASCII_W 32
#define ASCII_H 16
static const char *ascii_lut = "@%#*+=-:. ";

void asciiart(uint32_t *img)
{
    int levels = strlen(ascii_lut) - 1;
    int step_x = IMAGE_X / ASCII_W;
    int step_y = IMAGE_Y / ASCII_H;

    for (int y = 0; y < IMAGE_Y; y += step_y) {
        for (int x = 0; x < IMAGE_X; x += step_x) {
            uint32_t p = img[y * IMAGE_X + x];
            uint8_t r = (p & 0xFF) ^ 0x80;
            uint8_t g = ((p >> 8) & 0xFF) ^ 0x80;
            uint8_t b = ((p >> 16) & 0xFF) ^ 0x80;

            uint8_t yval = (3 * r + 4 * g + b) >> 3;
            char c = ascii_lut[levels - (yval * levels / 255)];
            putchar(c);
        }
        putchar('\n');
    }
}
// ---------------------------------------

void capture_image(void)
{
    uint8_t *raw, *data;
    uint32_t len, w, h;
    int cnt = 0;

    camera_start_capture_image();
    camera_get_image(&raw, &len, &w, &h);

    for (int y = 0; y < h; y++) {
        while ((data = get_camera_stream_buffer()) == NULL);
        for (int x = 0; x < w * 4; x += 4) {
            uint8_t r = data[x];
            uint8_t g = data[x + 1];
            uint8_t b = data[x + 2];
            cnn_input[cnt++] = ((b << 16) | (g << 8) | r) ^ 0x00808080;
        }
        release_camera_stream_buffer();
    }
}

int main(void)
{
    int i, digs, tens;

    MXC_ICC_Enable(MXC_ICC0);
    MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
    SystemCoreClockUpdate();

    printf("\n=== Car vs Bicycle Camera Demo III ===\n");

    MXC_DMA_Init();
    int dma = MXC_DMA_AcquireChannel();

    Camera_Power(POWER_ON);
    camera_init(CAMERA_FREQ);
    camera_setup(IMAGE_X, IMAGE_Y, PIXFORMAT_RGB888,
                 FIFO_THREE_BYTE, STREAMING_DMA, dma);

    cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK,
               MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);

    cnn_init();
    cnn_load_weights();
    cnn_load_bias();
    cnn_configure();

    printf("Press PB1 to capture image\n");

    while (1) {
        while (!PB_Get(0));   // wait press
        MXC_Delay(200000);    // debounce

        capture_image();

        printf("\n--- CAMERA ASCII PREVIEW ---\n");
        asciiart(cnn_input);

        cnn_start();
        for (i = 0; i < IMAGE_X * IMAGE_Y; i++) {
            while (*((volatile uint32_t*)0x50000004) & 1);
            *((volatile uint32_t*)0x50000008) = cnn_input[i];
        }

        while (cnn_time == 0) __WFI();

        cnn_unload((uint32_t*)ml_data);
        softmax_q17p14_q15((q31_t*)ml_data, CNN_NUM_OUTPUTS, ml_softmax);

        printf("\nInference time: %dus\n", cnn_time);
        printf("Classification results:\n");

        for (i = 0; i < CNN_NUM_OUTPUTS; i++) {
            digs = (1000 * ml_softmax[i] + 0x4000) >> 15;
            tens = digs % 10;
            digs /= 10;
            printf("[%7d] %s: %d.%d%%\n",
                   ml_data[i], classes[i], digs, tens);
        }

        cnn_time = 0;
        printf("\nPress PB1 to capture again\n");
    }
}
