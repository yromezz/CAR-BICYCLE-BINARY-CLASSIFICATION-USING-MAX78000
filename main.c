// /*******************************************************************************
// * Copyright (C) 2019-2023 Maxim Integrated Products, Inc., All rights Reserved.
// *
// * This software is protected by copyright laws of the United States and
// * of foreign countries. This material may also be protected by patent laws
// * and technology transfer regulations of the United States and of foreign
// * countries. This software is furnished under a license agreement and/or a
// * nondisclosure agreement and may only be used or reproduced in accordance
// * with the terms of those agreements. Dissemination of this information to
// * any party or parties not specified in the license agreement and/or
// * nondisclosure agreement is expressly prohibited.
// *
// * The above copyright notice and this permission notice shall be included
// * in all copies or substantial portions of the Software.
// *
// * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// * IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
// * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// * OTHER DEALINGS IN THE SOFTWARE.
// *
// * Except as contained in this notice, the name of Maxim Integrated
// * Products, Inc. shall not be used except as stated in the Maxim Integrated
// * Products, Inc. Branding Policy.
// *
// * The mere transfer of this software does not imply any licenses
// * of trade secrets, proprietary technology, copyrights, patents,
// * trademarks, maskwork rights, or any other form of intellectual
// * property whatsoever. Maxim Integrated Products, Inc. retains all
// * ownership rights.
// *******************************************************************************/

// // CarBicycle
// // This file was @generated by ai8xize.py --test-dir C:/MaximSDK/Examples/MAX78000/CNN --prefix CarBicycle --checkpoint-file ../ai8x-training/logs/2025.11.11-010241/CarBicycle-qat8-q.pth.tar --config-file networks/CarBicycle-hwc.yaml --sample-input ../ai8x-training/logs/2025.12.22-204923/sample_carbicycle.npy --fifo --softmax --device MAX78000 --timer 0 --display-checkpoint --verbose

// #include <stdlib.h>
// #include <stdint.h>
// #include <string.h>
// #include <stdio.h>
// #include "mxc.h"
// #include "cnn.h"
// #include "sampledata.h"
// #include "sampleoutput.h"

// volatile uint32_t cnn_time; // Stopwatch

// void fail(void)
// {
//   printf("\n*** FAIL ***\n\n");
//   while (1);
// }

// // Data input: HWC 3x128x128 (49152 bytes total / 16384 bytes per channel):
// static const uint32_t input_0[] = SAMPLE_INPUT_0;
// void load_input(void)
// {
//   // This function loads the sample data input -- replace with actual data

//   int i;
//   const uint32_t *in0 = input_0;

//   for (i = 0; i < 16384; i++) {
//     // Remove the following line if there is no risk that the source would overrun the FIFO:
//     while (((*((volatile uint32_t *) 0x50000004) & 1)) != 0); // Wait for FIFO 0
//     *((volatile uint32_t *) 0x50000008) = *in0++; // Write FIFO 0
//   }
// }

// // Expected output of layer 6 for CarBicycle given the sample input (known-answer test)
// // Delete this function for production code
// static const uint32_t sample_output[] = SAMPLE_OUTPUT;
// int check_output(void)
// {
//   int i;
//   uint32_t mask, len;
//   volatile uint32_t *addr;
//   const uint32_t *ptr = sample_output;

//   while ((addr = (volatile uint32_t *) *ptr++) != 0) {
//     mask = *ptr++;
//     len = *ptr++;
//     for (i = 0; i < len; i++)
//       if ((*addr++ & mask) != *ptr++) {
//         printf("Data mismatch (%d/%d) at address 0x%08x: Expected 0x%08x, read 0x%08x.\n",
//                i + 1, len, addr - 1, *(ptr - 1), *(addr - 1) & mask);
//         return CNN_FAIL;
//       }
//   }

//   return CNN_OK;
// }

// // Classification layer:
// static int32_t ml_data[CNN_NUM_OUTPUTS];
// static q15_t ml_softmax[CNN_NUM_OUTPUTS];

// void softmax_layer(void)
// {
//   cnn_unload((uint32_t *) ml_data);
//   softmax_q17p14_q15((const q31_t *) ml_data, CNN_NUM_OUTPUTS, ml_softmax);
// }

// int main(void)
// {
//   int i;
//   int digs, tens;

//   MXC_ICC_Enable(MXC_ICC0); // Enable cache

//   // Switch to 100 MHz clock
//   MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
//   SystemCoreClockUpdate();

//   printf("Waiting...\n");

//   // DO NOT DELETE THIS LINE:
//   MXC_Delay(SEC(2)); // Let debugger interrupt if needed

//   // Enable peripheral, enable CNN interrupt, turn on CNN clock
//   // CNN clock: APB (50 MHz) div 1
//   cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);

//   printf("\n*** CNN Inference Test CarBicycle ***\n");

//   cnn_init(); // Bring state machine into consistent state
//   cnn_load_weights(); // Load kernels
//   cnn_load_bias();
//   cnn_configure(); // Configure state machine
//   cnn_start(); // Start CNN processing
//   load_input(); // Load data input via FIFO

//   while (cnn_time == 0)
//     MXC_LP_EnterSleepMode(); // Wait for CNN

//   if (check_output() != CNN_OK) fail();
//   softmax_layer();

//   printf("\n*** PASS ***\n\n");

// #ifdef CNN_INFERENCE_TIMER
//   printf("Approximate data loading and inference time: %u us\n\n", cnn_time);
// #endif

//   cnn_disable(); // Shut down CNN clock, disable peripheral

//   printf("Classification results:\n");
//   for (i = 0; i < CNN_NUM_OUTPUTS; i++) {
//     digs = (1000 * ml_softmax[i] + 0x4000) >> 15;
//     tens = digs % 10;
//     digs = digs / 10;
//     printf("[%7d] -> Class %d: %d.%d%%\n", ml_data[i], i, digs, tens);
//   }

//   return 0;
// }

// /*
//   SUMMARY OF OPS
//   Hardware: 51,368,960 ops (50,432,000 macc; 936,960 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 0: 7,340,032 ops (7,077,888 macc; 262,144 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 1: 19,267,584 ops (18,874,368 macc; 393,216 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 2: 19,070,976 ops (18,874,368 macc; 196,608 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 3: 4,792,320 ops (4,718,592 macc; 73,728 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 4: 600,064 ops (589,824 macc; 10,240 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 5: 295,936 ops (294,912 macc; 1,024 comp; 0 add; 0 mul; 0 bitwise)
//     Layer 6: 2,048 ops (2,048 macc; 0 comp; 0 add; 0 mul; 0 bitwise)

//   RESOURCE USAGE
//   Weight memory: 57,776 bytes out of 442,368 bytes total (13.1%)
//   Bias memory:   2 bytes out of 2,048 bytes total (0.1%)
// */



















/*******************************************************************************
* Copyright (C) 2019-2023 Maxim Integrated Products, Inc.
* All rights Reserved.
*******************************************************************************/

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "mxc.h"
#include "cnn.h"
#include "sampledata.h"
#include "sampleoutput.h"
#include "mxc_device.h"
#include "mxc_sys.h"
#include "fcr_regs.h"
#include "icc.h"
#include "led.h"
#include "tmr.h"
#include "dma.h"
#include "pb.h"
#include "mxc_delay.h"
#include "camera.h"

// ================= Configuration =================
#define ASCII_ART
#define IMAGE_SIZE_X (128)
#define IMAGE_SIZE_Y (128)
#define CAMERA_FREQ (5 * 1000 * 1000)

// CNN input buffer (HWC 3x128x128)
static uint32_t input_0[IMAGE_SIZE_X * IMAGE_SIZE_Y];

// CNN output
static int32_t ml_data[CNN_NUM_OUTPUTS];
static q15_t ml_softmax[CNN_NUM_OUTPUTS];

// Stopwatch
volatile uint32_t cnn_time;

// ================= ASCII Art =====================
#ifdef ASCII_ART
char *brightness = "@%#*+=-:.";
#define RATIO 2

void asciiart(uint8_t *img) {
    int skip_x, skip_y;
    uint8_t r, g, b, Y;
    uint8_t *srcPtr = img;
    int l = strlen(brightness) - 1;

    skip_x = RATIO;
    skip_y = RATIO;

    for(int i = 0; i < IMAGE_SIZE_Y; i++) {
        for(int j = 0; j < IMAGE_SIZE_X; j++) {
            r = *srcPtr++ ^ 0x80;
            g = *srcPtr++ ^ 0x80;
            b = *srcPtr++ ^ 0x80;
            srcPtr++; // skip MSB

            Y = (3*r + b + 4*g) >> 3; // luminance
            if ((skip_x == RATIO) && (skip_y == RATIO))
                printf("%c", brightness[l - (Y*l/255)]);
            skip_x++;
            if (skip_x > RATIO) skip_x = 1;
        }
        skip_y++;
        if (skip_y > RATIO) {
            printf("\n");
            skip_y = 1;
        }
    }
}
#endif

// ================= Fail Function =================
void fail(void){
    printf("\n*** FAIL ***\n\n");
    while(1);
}

// ================= Load CNN Input =================
void load_input(void){
    int i;
    const uint32_t *in0 = input_0;

    for (i = 0; i < 16384; i++) {
        uint32_t timeout = 10000000;
        while (((*((volatile uint32_t *) 0x50000004) & 1)) != 0) {
            if (timeout-- == 0) {
                printf("ERROR: FIFO timeout at word %d!\n", i);
                return;
            }
        }
        *((volatile uint32_t *) 0x50000008) = *in0++;
    }
}

// ================= Camera Capture =================
void capture_process_camera(void){
    uint8_t *raw;
    uint32_t imgLen;
    uint32_t w, h;
    int cnt = 0;
    uint8_t r,g,b;
    uint16_t rgb;
    uint8_t *data = NULL;
    stream_stat_t *stat;

    printf("Starting camera capture...\n");
    camera_start_capture_image();
    camera_get_image(&raw, &imgLen, &w, &h);
    printf("W:%d H:%d L:%d\n", w, h, imgLen);

    for(int row = 0; row < h; row++) {
        uint32_t stream_timeout = 1000000;
        while ((data = get_camera_stream_buffer()) == NULL) {
            if (camera_is_image_rcv()) break;
            if (stream_timeout-- == 0) {
                printf("ERROR: Camera stream timeout!\n");
                return;
            }
        }

        if (data == NULL) break;

        for(int k=0; k<4*w; k+=4){
            r = data[k];
            g = data[k+1];
            b = data[k+2];
            input_0[cnt++] = ((b<<16)|(g<<8)|r)^0x00808080;
        }
        release_camera_stream_buffer();
    }

    stat = get_camera_stream_statistic();
    if (stat->overflow_count > 0) {
        printf("OVERFLOW DETECTED = %d\n", stat->overflow_count);
        LED_On(LED2);
    } else {
        printf("Camera stream OK\n");
    }
}

// ================= Softmax =================
void softmax_layer(void){
    cnn_unload((uint32_t *) ml_data);
    softmax_q17p14_q15((const q31_t *) ml_data, CNN_NUM_OUTPUTS, ml_softmax);
}

// ================= Main =================
int main(void){
    int i, digs, tens, ret = 0;
    int result[CNN_NUM_OUTPUTS];

    // Classes for CarBicycle
    const char classes[CNN_NUM_OUTPUTS][20] = {"Car","Bicycle"};

    MXC_ICC_Enable(MXC_ICC0); // Enable cache
    MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
    SystemCoreClockUpdate();
    MXC_Delay(SEC(2));

    // CNN setup
    cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);
    cnn_init();
    cnn_load_weights();
    cnn_load_bias();
    cnn_configure();
    printf("CNN initialized successfully\n");

    // Camera setup
    MXC_DMA_Init();
    int dma_channel = MXC_DMA_AcquireChannel();
    camera_init(CAMERA_FREQ);
    ret = camera_setup(IMAGE_SIZE_X, IMAGE_SIZE_Y, PIXFORMAT_RGB888, FIFO_THREE_BYTE, STREAMING_DMA, dma_channel);
    camera_write_reg(0x11, 0x0);

    printf("********** Press PB1(SW1) to capture an image **********\n");
    while (!PB_Get(0)) {}

    while (1){
        LED_Off(LED1);
        LED_Off(LED2);

        printf("\n--- Starting capture and inference cycle ---\n");
        capture_process_camera();

        cnn_start();
        load_input();

        uint32_t cnn_timeout = 5000000;
        while (cnn_time==0) __WFI();
        cnn_time = 0;

        softmax_layer();

        printf("\nClassification results:\n");
        for (i=0; i<CNN_NUM_OUTPUTS; i++){
            digs = (1000*ml_softmax[i]+0x4000)>>15;
            tens = digs%10;
            digs = digs/10;
            result[i] = digs;
            printf("[%7d] -> %20s: %d.%d%%\n", ml_data[i], classes[i], result[i], tens);
        }

#ifdef ASCII_ART
        printf("\nASCII Art:\n");
        asciiart((uint8_t*)input_0);
#endif

        printf("********** Press PB1(SW1) to capture another image **********\n");
        while(!PB_Get(0)) {}
    }

    return 0;
}








